# API Integration & Service Patterns

## üåê API Architecture

### Service Layer Structure
```
src/services/
‚îú‚îÄ‚îÄ api.ts              # Base API configuration
‚îú‚îÄ‚îÄ repositories/       # Data access layer
‚îÇ   ‚îú‚îÄ‚îÄ index.ts       # Repository exports
‚îÇ   ‚îú‚îÄ‚îÄ chatRepository.ts
‚îÇ   ‚îî‚îÄ‚îÄ emotionRepository.ts
‚îî‚îÄ‚îÄ pdfService.ts      # PDF generation service
```

### Base API Configuration
Reference [src/services/api.ts](mdc:src/services/api.ts) for axios configuration and interceptors.

## üö® CRITICAL API RULES

### ‚úÖ MUST DO
1. **Use repository pattern** - Separate data access from components
2. **Define TypeScript interfaces** for all API responses
3. **Handle loading and error states** in all API calls
4. **Use proper HTTP status codes** for error handling
5. **Implement request/response interceptors** for common logic
6. **Use environment variables** for API endpoints
7. **Implement proper error boundaries** for API failures
8. **Cache responses** when appropriate

### ‚ùå NEVER DO
1. **Don't make API calls directly in components** - Use repositories
2. **Don't ignore error handling** - Always handle API errors
3. **Don't use any type** for API responses
4. **Don't hardcode API endpoints** - Use environment variables
5. **Don't make synchronous API calls** - Always use async/await
6. **Don't store sensitive data** in localStorage
7. **Don't bypass authentication** - Always include auth headers

## üéØ Repository Pattern

### Repository Structure
Reference [src/services/repositories/](mdc:src/services/repositories/) for implementation examples:

```typescript
// Base repository interface
interface BaseRepository<T> {
  getAll(): Promise<T[]>;
  getById(id: string): Promise<T>;
  create(data: Partial<T>): Promise<T>;
  update(id: string, data: Partial<T>): Promise<T>;
  delete(id: string): Promise<void>;
}

// Specific repository implementation
export class EmotionRepository {
  private readonly baseUrl = '/api/emotions';
  
  async analyzeEmotion(data: EmotionAnalysisRequest): Promise<EmotionAnalysis> {
    try {
      const response = await api.post<EmotionAnalysis>(`${this.baseUrl}/analyze`, data);
      return response.data;
    } catch (error) {
      throw new ApiError('Failed to analyze emotion', error);
    }
  }
  
  async getEmotionHistory(): Promise<EmotionAnalysis[]> {
    try {
      const response = await api.get<EmotionAnalysis[]>(`${this.baseUrl}/history`);
      return response.data;
    } catch (error) {
      throw new ApiError('Failed to fetch emotion history', error);
    }
  }
}
```

### API Service Configuration
```typescript
import axios, { AxiosInstance, AxiosResponse, AxiosError } from 'axios';

// Base API configuration
const api: AxiosInstance = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor
api.interceptors.request.use(
  (config) => {
    // Add auth token
    const token = localStorage.getItem('authToken');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor
api.interceptors.response.use(
  (response: AxiosResponse) => {
    return response;
  },
  (error: AxiosError) => {
    if (error.response?.status === 401) {
      // Handle unauthorized access
      localStorage.removeItem('authToken');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

export { api };
```

## üé® Component Integration

### Hook-based API Integration
```typescript
interface UseApiReturn<T> {
  data: T | null;
  loading: boolean;
  error: Error | null;
  refetch: () => Promise<void>;
}

export function useApi<T>(
  apiCall: () => Promise<T>,
  dependencies: any[] = []
): UseApiReturn<T> {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const fetchData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const result = await apiCall();
      setData(result);
    } catch (err) {
      setError(err as Error);
    } finally {
      setLoading(false);
    }
  }, dependencies);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return {
    data,
    loading,
    error,
    refetch: fetchData,
  };
}
```

### Component Usage Pattern
```typescript
import { emotionRepository } from '../services/repositories';

export function EmotionAnalysisComponent() {
  const { data: emotions, loading, error, refetch } = useApi(
    () => emotionRepository.getEmotionHistory(),
    []
  );

  const handleAnalyze = async (input: string) => {
    try {
      const result = await emotionRepository.analyzeEmotion({ text: input });
      // Handle success
      refetch(); // Refresh the list
    } catch (error) {
      // Handle error
    }
  };

  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;

  return (
    <div>
      {/* Render emotions */}
    </div>
  );
}
```

## üõ°Ô∏è Error Handling

### Custom Error Classes
```typescript
export class ApiError extends Error {
  constructor(
    message: string,
    public originalError?: any,
    public statusCode?: number
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

export class ValidationError extends Error {
  constructor(
    message: string,
    public field?: string
  ) {
    super(message);
    this.name = 'ValidationError';
  }
}
```

### Error Boundary for API Errors
```typescript
interface ApiErrorBoundaryProps {
  children: React.ReactNode;
  fallback?: React.ComponentType<{ error: ApiError }>;
}

export class ApiErrorBoundary extends React.Component<ApiErrorBoundaryProps> {
  state = { hasError: false, error: null as ApiError | null };

  static getDerivedStateFromError(error: Error) {
    if (error instanceof ApiError) {
      return { hasError: true, error };
    }
    return { hasError: false, error: null };
  }

  render() {
    if (this.state.hasError) {
      const FallbackComponent = this.props.fallback || DefaultApiErrorFallback;
      return <FallbackComponent error={this.state.error!} />;
    }

    return this.props.children;
  }
}

function DefaultApiErrorFallback({ error }: { error: ApiError }) {
  return (
    <div className="p-4 bg-red-50 border border-red-200 rounded-lg">
      <h2 className="text-red-800 font-semibold">API Error</h2>
      <p className="text-red-600 text-sm">{error.message}</p>
      {error.statusCode && (
        <p className="text-red-500 text-xs">Status: {error.statusCode}</p>
      )}
    </div>
  );
}
```

## üîÑ State Management Integration

### Zustand Store Integration
```typescript
// Store actions for API calls
interface AppState {
  // ... existing state
  
  // API actions
  fetchEmotionHistory: () => Promise<void>;
  analyzeEmotion: (data: EmotionAnalysisRequest) => Promise<void>;
  setApiError: (error: Error | null) => void;
}

export const useAppStore = create<AppState>()(
  devtools(
    persist(
      (set, get) => ({
        // ... existing state and actions
        
        fetchEmotionHistory: async () => {
          try {
            set({ isLoading: true, apiError: null });
            const history = await emotionRepository.getEmotionHistory();
            set({
              currentSession: {
                ...get().currentSession,
                emotionHistory: history,
              },
              isLoading: false,
            });
          } catch (error) {
            set({ 
              isLoading: false, 
              apiError: error as Error 
            });
          }
        },
        
        analyzeEmotion: async (data) => {
          try {
            set({ isLoading: true, apiError: null });
            const result = await emotionRepository.analyzeEmotion(data);
            get().addEmotionAnalysis(result);
            set({ isLoading: false });
          } catch (error) {
            set({ 
              isLoading: false, 
              apiError: error as Error 
            });
          }
        },
        
        setApiError: (error) => set({ apiError: error }),
      }),
      {
        name: 'bemore-store',
      }
    )
  )
);
```

## üìä Data Caching

### Simple Cache Implementation
```typescript
class ApiCache {
  private cache = new Map<string, { data: any; timestamp: number }>();
  private readonly ttl = 5 * 60 * 1000; // 5 minutes

  set(key: string, data: any): void {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
    });
  }

  get(key: string): any | null {
    const item = this.cache.get(key);
    if (!item) return null;

    if (Date.now() - item.timestamp > this.ttl) {
      this.cache.delete(key);
      return null;
    }

    return item.data;
  }

  clear(): void {
    this.cache.clear();
  }
}

export const apiCache = new ApiCache();
```

### Cached Repository Method
```typescript
export class CachedEmotionRepository extends EmotionRepository {
  async getEmotionHistory(): Promise<EmotionAnalysis[]> {
    const cacheKey = 'emotion-history';
    const cached = apiCache.get(cacheKey);
    
    if (cached) {
      return cached;
    }

    const data = await super.getEmotionHistory();
    apiCache.set(cacheKey, data);
    return data;
  }
}
```

## üîê Authentication Integration

### Auth Service
```typescript
export class AuthService {
  private readonly baseUrl = '/api/auth';

  async login(credentials: LoginCredentials): Promise<AuthResponse> {
    try {
      const response = await api.post<AuthResponse>(`${this.baseUrl}/login`, credentials);
      const { token, user } = response.data;
      
      localStorage.setItem('authToken', token);
      return response.data;
    } catch (error) {
      throw new ApiError('Login failed', error);
    }
  }

  async logout(): Promise<void> {
    try {
      await api.post(`${this.baseUrl}/logout`);
    } finally {
      localStorage.removeItem('authToken');
    }
  }

  async refreshToken(): Promise<string> {
    try {
      const response = await api.post<{ token: string }>(`${this.baseUrl}/refresh`);
      const { token } = response.data;
      localStorage.setItem('authToken', token);
      return token;
    } catch (error) {
      throw new ApiError('Token refresh failed', error);
    }
  }
}
```

## üìÑ File Upload & Download

### File Upload Service
```typescript
export class FileService {
  async uploadFile(file: File, type: 'image' | 'video'): Promise<FileUploadResponse> {
    const formData = new FormData();
    formData.append('file', file);
    formData.append('type', type);

    try {
      const response = await api.post<FileUploadResponse>('/api/files/upload', formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      });
      return response.data;
    } catch (error) {
      throw new ApiError('File upload failed', error);
    }
  }

  async downloadFile(fileId: string): Promise<Blob> {
    try {
      const response = await api.get(`/api/files/${fileId}`, {
        responseType: 'blob',
      });
      return response.data;
    } catch (error) {
      throw new ApiError('File download failed', error);
    }
  }
}
```

## üîÑ Real-time Updates

### WebSocket Integration
```typescript
export class WebSocketService {
  private ws: WebSocket | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;

  connect(url: string): void {
    this.ws = new WebSocket(url);
    
    this.ws.onopen = () => {
      console.log('WebSocket connected');
      this.reconnectAttempts = 0;
    };

    this.ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      this.handleMessage(data);
    };

    this.ws.onclose = () => {
      console.log('WebSocket disconnected');
      this.attemptReconnect(url);
    };

    this.ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
  }

  private attemptReconnect(url: string): void {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      setTimeout(() => {
        this.connect(url);
      }, 1000 * this.reconnectAttempts);
    }
  }

  private handleMessage(data: any): void {
    // Handle different message types
    switch (data.type) {
      case 'emotion_update':
        // Update emotion state
        break;
      case 'chat_message':
        // Add chat message
        break;
      default:
        console.warn('Unknown message type:', data.type);
    }
  }

  send(message: any): void {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(message));
    }
  }

  disconnect(): void {
    this.ws?.close();
  }
}
```
description:
globs:
alwaysApply: false
---
