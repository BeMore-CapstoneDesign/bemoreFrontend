# React Component Patterns & Best Practices

## üß© Component Architecture

### Component Organization
```
src/components/
‚îú‚îÄ‚îÄ ui/           # Base UI components (Button, Card, Input)
‚îú‚îÄ‚îÄ layout/       # Layout components (Navigation, Layout)
‚îú‚îÄ‚îÄ analysis/     # Feature-specific components
‚îî‚îÄ‚îÄ hoc/          # Higher-Order Components
```

### Component File Structure
Reference existing components like [src/components/ui/Button.tsx](mdc:src/components/ui/Button.tsx) and [src/components/ui/Card.tsx](mdc:src/components/ui/Card.tsx).

## üö® CRITICAL COMPONENT RULES

### ‚úÖ MUST DO
1. **Use function components** - No class components
2. **Export as named functions** - `export function ComponentName()`
3. **Extend HTML attributes** in props using `React.HTMLAttributes`
4. **Use TypeScript interfaces** for all props
5. **Implement proper error boundaries** for complex components
6. **Use composition pattern** with sub-components
7. **Handle loading and error states** in async components
8. **Use React.memo** for expensive components

### ‚ùå NEVER DO
1. **Don't use class components** - Use function components only
2. **Don't use default exports** - Use named exports
3. **Don't inline complex logic** - Extract to custom hooks
4. **Don't create components without props interface**
5. **Don't use any type** - Always define proper types
6. **Don't mutate props** - Props are immutable
7. **Don't create components that are too large** - Split into smaller components

## üéØ Component Patterns

### Basic Component Structure
```typescript
import React from 'react';
import { cn } from '../../utils/cn';

interface ComponentProps extends React.HTMLAttributes<HTMLDivElement> {
  children: React.ReactNode;
  variant?: 'default' | 'elevated';
  size?: 'sm' | 'md' | 'lg';
}

export function Component({ 
  children, 
  variant = 'default',
  size = 'md',
  className, 
  ...props 
}: ComponentProps) {
  const baseClasses = "base-styles";
  const variantClasses = {
    default: "default-variant",
    elevated: "elevated-variant"
  };
  
  return (
    <div 
      className={cn(
        baseClasses,
        variantClasses[variant],
        className
      )}
      {...props}
    >
      {children}
    </div>
  );
}
```

### Composition Pattern
```typescript
// Main component
export function Card({ children, variant, className, ...props }: CardProps) {
  return (
    <div className={cn(cardClasses, className)} {...props}>
      {children}
    </div>
  );
}

// Sub-components
export function CardHeader({ children, className, ...props }: CardHeaderProps) {
  return (
    <div className={cn(headerClasses, className)} {...props}>
      {children}
    </div>
  );
}

export function CardContent({ children, className, ...props }: CardContentProps) {
  return (
    <div className={cn(contentClasses, className)} {...props}>
      {children}
    </div>
  );
}

// Usage
<Card variant="elevated">
  <CardHeader>
    <h3>Title</h3>
  </CardHeader>
  <CardContent>
    <p>Content</p>
  </CardContent>
</Card>
```

## üé® UI Component Patterns

### Button Component Pattern
Reference [src/components/ui/Button.tsx](mdc:src/components/ui/Button.tsx):

```typescript
interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  children: React.ReactNode;
  variant?: 'primary' | 'secondary' | 'outline' | 'ghost' | 'gradient';
  size?: 'sm' | 'md' | 'lg' | 'xl';
  loading?: boolean;
  icon?: React.ReactNode;
  iconPosition?: 'left' | 'right';
}

export function Button({ 
  children, 
  variant = 'primary', 
  size = 'md',
  loading = false,
  icon,
  iconPosition = 'left',
  className, 
  disabled,
  ...props 
}: ButtonProps) {
  // Implementation with variant and size classes
}
```

### Card Component Pattern
Reference [src/components/ui/Card.tsx](mdc:src/components/ui/Card.tsx):

```typescript
interface CardProps extends React.HTMLAttributes<HTMLDivElement> {
  children: React.ReactNode;
  variant?: 'default' | 'elevated' | 'outlined' | 'gradient';
  hover?: boolean;
}

export function Card({ 
  children, 
  variant = 'default', 
  hover = false,
  className, 
  ...props 
}: CardProps) {
  // Implementation with variant and hover classes
}
```

## üì± Page Component Patterns

### Page Layout Structure
```typescript
export function PageName() {
  return (
    <div className="min-h-screen bg-gray-50">
      <Navigation />
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div className="space-y-8">
          {/* Page header */}
          <div className="text-center space-y-4">
            <h1 className="text-3xl font-bold text-gray-900">Page Title</h1>
            <p className="text-lg text-gray-600">Page description</p>
          </div>
          
          {/* Page content */}
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {/* Content cards */}
          </div>
        </div>
      </main>
    </div>
  );
}
```

### Async Component Pattern
```typescript
export function AsyncComponent() {
  const [data, setData] = useState<DataType | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const result = await apiCall();
        setData(result);
      } catch (err) {
        setError(err as Error);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, []);

  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;
  if (!data) return <EmptyState />;

  return (
    <div>
      {/* Render data */}
    </div>
  );
}
```

## üîß Custom Hooks Pattern

### Hook Structure
```typescript
interface UseCustomHookReturn {
  data: DataType;
  loading: boolean;
  error: Error | null;
  refetch: () => void;
}

export function useCustomHook(): UseCustomHookReturn {
  const [data, setData] = useState<DataType | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const fetchData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const result = await apiCall();
      setData(result);
    } catch (err) {
      setError(err as Error);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return {
    data: data || defaultValue,
    loading,
    error,
    refetch: fetchData,
  };
}
```

## üé≠ State Management Integration

### Zustand Integration
```typescript
import { useAppStore } from '../modules/store';

export function ComponentWithStore() {
  const { user, setUser, isLoading } = useAppStore();
  
  const handleUserUpdate = (newUser: UserProfile) => {
    setUser(newUser);
  };
  
  return (
    <div>
      {isLoading ? (
        <LoadingSpinner />
      ) : (
        <UserProfile user={user} onUpdate={handleUserUpdate} />
      )}
    </div>
  );
}
```

## üõ°Ô∏è Error Boundary Pattern

### Error Boundary Component
```typescript
interface ErrorBoundaryProps {
  children: React.ReactNode;
  fallback?: React.ComponentType<{ error: Error }>;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      const FallbackComponent = this.props.fallback || DefaultErrorFallback;
      return <FallbackComponent error={this.state.error!} />;
    }

    return this.props.children;
  }
}

function DefaultErrorFallback({ error }: { error: Error }) {
  return (
    <div className="p-4 bg-red-50 border border-red-200 rounded-lg">
      <h2 className="text-red-800 font-semibold">Something went wrong</h2>
      <p className="text-red-600 text-sm">{error.message}</p>
    </div>
  );
}
```

## üé® Styling Integration

### Class Name Utility
Reference [src/utils/cn.ts](mdc:src/utils/cn.ts) for class merging:

```typescript
import { cn } from '../../utils/cn';

className={cn(
  baseClasses,
  variantClasses[variant],
  sizeClasses[size],
  className
)}
```

### CSS Variables Usage
```typescript
// Use CSS variables for colors
className="bg-primary text-white hover:bg-primary-dark"

// Use semantic colors
className="text-success" // Green
className="text-warning" // Orange
className="text-error"   // Red
```

## üì± Responsive Design

### Responsive Component Pattern
```typescript
export function ResponsiveComponent() {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
      <Card className="p-4 sm:p-6">
        <h3 className="text-lg sm:text-xl font-semibold">Title</h3>
        <p className="text-sm sm:text-base">Content</p>
      </Card>
    </div>
  );
}
```

## üîÑ Performance Optimization

### React.memo Usage
```typescript
interface ExpensiveComponentProps {
  data: ComplexDataType;
  onUpdate: (data: ComplexDataType) => void;
}

export const ExpensiveComponent = React.memo<ExpensiveComponentProps>(
  ({ data, onUpdate }) => {
    // Expensive rendering logic
    return <div>{/* Complex JSX */}</div>;
  }
);
```

### useMemo and useCallback
```typescript
export function OptimizedComponent({ items }: { items: Item[] }) {
  const sortedItems = useMemo(() => {
    return items.sort((a, b) => a.name.localeCompare(b.name));
  }, [items]);

  const handleItemClick = useCallback((item: Item) => {
    // Handle item click
  }, []);

  return (
    <div>
      {sortedItems.map(item => (
        <ItemComponent 
          key={item.id} 
          item={item} 
          onClick={handleItemClick}
        />
      ))}
    </div>
  );
}
```
description:
globs:
alwaysApply: false
---
